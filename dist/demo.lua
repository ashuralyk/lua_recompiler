-- Generated by node-lua-distiller(version: 0.2.5)  at Sat Sep 18 2021 17:09:58 GMT+0800 (China Standard Time)

---------------------------------------


if __DISTILLER == nil then
  __DISTILLER = nil
  __DISTILLER = {
    FACTORIES = { },
	PACKAGE_LOADED = { },
    __nativeRequire = require,
    require = function(id)
      assert(type(id) == "string", "require invalid id:" .. tostring(id))
      if __DISTILLER.PACKAGE_LOADED[id] then
        return __DISTILLER.PACKAGE_LOADED[id]
      end
      if __DISTILLER.FACTORIES[id] then
        local func = __DISTILLER.FACTORIES[id]
        __DISTILLER.PACKAGE_LOADED[id] = func(__DISTILLER.require) or true
        return __DISTILLER.PACKAGE_LOADED[id]
      end
      return __DISTILLER.__nativeRequire(id)
    end,
    define = function(self, id, factory)
      assert(type(id) == "string", "invalid id:" .. tostring(id))
      assert(type(factory) == "function", "invalid factory:" .. tostring(factory))
      if self.PACKAGE_LOADED[id] == nil and self.FACTORIES[id] == nil then
        self.FACTORIES[id] = factory
      else
        print("[__DISTILLER::define] module " .. tostring(id) .. " is already defined")
      end
    end,
    exec = function(self, id)
      local func = self.FACTORIES[id]
      assert(func, "missing factory method for id " .. tostring(id))
      func(__DISTILLER.require)
    end
  }
end



---------------------------------------


__DISTILLER:define("class", function(require)
local _class={}
function class(super)
    local class_type={}
    class_type.ctor     = false
    class_type.super    = super
    class_type.new      = 
        function(...)
            local obj={}
            do
                local create
                create = function(c,...)
                    if c.super then
                        create(c.super,...)
                    end
                    if c.ctor then
                        c.ctor(obj,...)
                    end
                end

                create(class_type,...)
            end
            setmetatable(obj,{ __index = _class[class_type] })
            return obj
        end
    local vtbl={}
    _class[class_type]=vtbl

    setmetatable(class_type,{__newindex=
        function(t,k,v)
            vtbl[k]=v
        end
    })
    
    if super then
        setmetatable(vtbl,{__index=
            function(t,k)
                local ret=_class[super][k]
                vtbl[k]=ret
                return ret
            end
        })
    end

    return class_type
end
end)



---------------------------------------


__DISTILLER:define("cards/base", function(require)

require "class"

local card = class()

function card:ctor()
	self.hash = ""
	self.cost = 0
	self.caster_effects = {}
	self.opposite_effects = {}
	self.caster_buffs = {}
	self.opposite_buffs = {}
end

function card:apply(caster, opposite)
	assert(caster.energy >= self.cost, "insufficient energy cost " .. self.cost .. " from " .. self.hash)
	caster.energy = caster.energy - self.cost
	Emit("cost", caster.id, caster.energy)
	for _, effect in ipairs(self.caster_effects) do
		assert(type(effect) == "function", "caster_effect in " .. self.hash .. " has non-function type")
		effect(caster)
	end
	for _, effect in ipairs(self.opposite_effects) do
		assert(type(effect) == "function", "opposite_effect in " .. self.hash .. " has non-function type")
		effect(opposite)
	end
	for _, buff in ipairs(self.caster_buffs) do
		assert(type(buff) == "table", "caster_buff in " .. self.hash .. " has non-table type")
		table.insert(caster.buffs, buff)
		Emit("buff", caster.id, buff.id, 0, buff.life)
	end
	for _, buff in ipairs(self.opposite_buffs) do
		assert(type(buff) == "table", "opposite_buff in " .. self.hash .. " has non-table type")
		table.insert(opposite.buffs, buff)
		Emit("buff", opposite.id, buff.id, 0, buff.life)
	end
end

return card

end)



---------------------------------------


__DISTILLER:define("cards/effects", function(require)

local effects = {}

-- 对指定玩家造成伤害
effects.damage = function (value, effect_name)
	return function (player)
		local applied_value = value
		for _, buff in ipairs(player.buffs) do
			local apply = buff["effects.damage"]
			if type(apply) == "function" then
				applied_value = apply(buff, player, value)
			end
		end
		player.hp = math.max(player.hp - applied_value, 0)
		Emit("damage", player.id, player.hp, effect_name)
	end
end

-- 恢复指定玩家的生命
effects.heal = function (value)
	return function (player)
		local applied_value = value
		for _, buff in ipairs(player.buffs) do
			local apply = buff["effects.heal"]
			if type(apply) == "function" then
				applied_value = apply(buff, player, value)
			end
		end
		player.hp = math.min(player.hp + applied_value, player.max_hp)
		Emit("heal", player.id, player.hp)
	end
end

-- 恢复指定玩家的能量
effects.empower = function (value)
	return function (player)
		local applied_value = value
		for _, buff in ipairs(player.buffs) do
			local apply = buff["effects.empower"]
			if type(apply) == "function" then
				applied_value = apply(buff, player, value)
			end
		end
		player.energy = math.min(player.energy + applied_value, player.max_energy)
		Emit("empower", player.id, player.energy)
	end
end

-- 指定玩家抽牌
effects.draw = function (value)
	return function (player)
		local applied_value = value
		for _, buff in ipairs(player.buffs) do
			local apply = buff["effects.draw"]
			if type(apply) == "function" then
				applied_value = apply(buff, player, value)
			end
		end
		for _ = 1, applied_value do
			player:draw()
		end
	end
end

-- 脱去指定玩家的BUFF并应用附加效果
effects.strip = function (value, subeffect)
	return function (player)
		local bs = {}
		if value <= 0 then
			for i in ipairs(player.buffs) do
				table.insert(bs, i)
			end
			player.buffs = {}
		else
			value = math.max(value, #player.buffs)
			for _ = 1, value do
				local i = math.random(#player.buffs)
				table.insert(bs, i)
				table.remove(player.buffs, i)
			end
		end
		Emit("strip", player.id, bs)
		local effect = assert(effects[subeffect.name] ~= nil, "bad subeffect name " .. subeffect.name)
		local apply = effect((#bs) * subeffect.factor)
		if subeffect.target == "owner" then
			apply(player)
		elseif subeffect.target == "opposite" then
			apply(player.kabletop:other_player())
		else
			error("unknown strip subeffect target " .. subeffect.target)
		end
	end
end

return effects

end)



---------------------------------------


__DISTILLER:define("cards/buffs", function(require)

local buffs = {}

-- 金钟罩：吸收伤害，在BUFF消失后对对方造成吸收的总伤害
buffs.healdefend = function (value, live_round)
	return {
		id = 2,
		surplus = value,
		accumulate = 0,
		life = live_round,
		["elapse"] = function (self, player, offset)
			self.life = self.life - 1
			if self.life <= 0 then
				player.hp = math.min(player.hp + self.accumulate, player.max_hp)
				Emit("heal", player.id, player.hp)
			end
			Emit("buff", player.id, self.id, offset, self.life)
			return self.life > 0
		end,
		["effects.damage"] = function (self, _, damage)
			local old = self.surplus
			self.surplus = math.max(0, self.surplus - damage)
			local change = old - self.surplus
			self.accumulate = self.accumulate + change
			return damage - change
		end
	}
end

-- 圣光：每一回合恢复指定血量
buffs.holylight = function (value, live_round)
	return {
		id = 4,
		life = live_round,
		["elapse"] = function (self, player, offset)
			self.life = self.life - 1
			player.hp = math.min(player.hp + value, player.max_hp)
			Emit("heal", player.id, player.hp)
			Emit("buff", player.id, self.id, offset, self.life)
			return self.life > 0
		end
	}
end

return buffs

end)



---------------------------------------


__DISTILLER:define("cards/instances", function(require)

local base = require "cards/base"
local effects = require "cards/effects"
local buffs = require "cards/buffs"

local function pack(...)
	return table.pack(...)
end

local function subeffect(name, target, factor)
	return {
		name = name,
		target = target,
		factor = factor
	}
end

local function generate(cost, caster_effects, opposite_effects, caster_buffs, opposite_buffs)
	return { 
		cost = cost,
		caster_effects = caster_effects,
		opposite_effects = opposite_effects,
		caster_buffs = caster_buffs,
		opposite_buffs = opposite_buffs
	}
end

local templates = {
	-- Chosen 破壁
	[1] = generate(
		2,
		nil,
		pack(effects.strip(1, subeffect("heal", "opposite", 2))),
		nil
	),
	-- Cultist 嗜血
	[2] = generate(
		4,
		pack(effects.heal(3)),
		pack(effects.damage(3, "bomb")),
		nil,
		nil
	),
	-- Ironclad 火焰匕首
	[3] = generate(
		1,
		pack(effects.damage(1, "thunder")),
		pack(effects.damage(3, "thunder")),
		nil,
		nil
	),
	-- Silent 超充
	[4] = generate(
		0,
		pack(effects.damage(3, "firebomb"), effects.empower(3)),
		nil,
		nil,
		nil
	),
	-- 充能
	["10ad3f5012ce514f409e4da4c011c24a31443488"] = generate(
		0,
		pack(effects.empower(2)),
		nil,
		nil,
		nil
	),
	-- 光明
	["d046a18f7e01cb42e911fae2f11ba60c9c6834f8"] = generate(
		5,
		nil,
		nil,
		pack(buffs.holylight(2, 3)),
		nil
	),
	-- 毒瘴
	["f37dfa5b009ea001acd3617886d9efecf31bb153"] = generate(
		2,
		pack(effects.damage(3, "firebomb"), effects.draw(1)),
		nil,
		nil
	),
	-- 心灵净化
	["97bff01bcad316a4b534ef221bd66da97018df90"] = generate(
		5,
		pack(effects.heal(2), effects.draw(1)),
		nil,
		nil
	),
	-- 雷鸣
	["36248218d2808d668ae3c0d35990c12712f6b9d2"] = generate(
		2,
		nil,
		pack(effects.damage(10, "firebomb")),
		nil,
		nil
	),
	-- 缴械
	["f49ac4925959733cc4c2b3a2663bde8c27b8dde2"] = generate(
		4,
		nil,
		nil,
		pack(buffs.healdefend(10, 3)),
		nil
	)
}

local instances = {}

for hash, template in pairs(templates) do
	instances[hash] = class(base)
	instances[hash].ctor = function (self)
		self.hash = hash
		self.cost = template.cost or 0
		self.caster_effects = template.caster_effects or {}
		self.opposite_effects = template.opposite_effects or {}
		self.caster_buffs = table.clone(template.caster_buffs or {})
		self.opposite_buffs = table.clone(template.opposite_buffs or {})
	end
end

function table.clone(object)
    local lookup_table = {}
    local function _copy(object)
        if type(object) ~= "table" then
            return object
        elseif lookup_table[object] then
            return lookup_table[object]
        end
        local new_table = {}
        lookup_table[object] = new_table
        for key, value in pairs(object) do
            new_table[_copy(key)] = _copy(value)
        end
        return setmetatable(new_table, getmetatable(object))
    end
    return _copy(object)
end

return instances

end)



---------------------------------------


__DISTILLER:define("player", function(require)

require "class"
local NFTs = require "cards/instances"

-- 玩家对象
local Player = class()

function Player:ctor(role, nfts, id, tabletop)
	self.id = id
	self.tabletop = tabletop
	self.max_hp = Cfg.MAX_HP
	self.max_energy = Cfg.MAX_ENERGY
	self.hp = self.max_hp
	self.energy = 0
	self.untapped_count = 6
	self.master_card = assert(NFTs[role], "no role nft " .. role).new()
	self.custom_cards = {}
	self.active_cards = {}
	self.buffs = {}

	for _, hash in ipairs(nfts) do
		local nft = assert(NFTs[hash], "no nft " .. hash .. " from player " .. id)
		table.insert(self.custom_cards, nft.new())
	end
end

function Player:spell(which)
	local card = assert(self.active_cards[which], "spelling card " .. which .. " doesn't exist")
	local opposite = self.tabletop:other_player()
	card:apply(self, opposite)
	table.remove(self.active_cards, which)
	Emit("spell_end", self.id, which, card.hash)
end

function Player:spell_master()
	local opposite = self.tabletop:other_player()
	self.master_card:apply(self, opposite)
	Emit("spell_end", self.id, 0, self.master_card.hash)
end

function Player:draw(count)
	for _ = 1, count or 1 do
		if #self.custom_cards > 0 then
			local which = math.random(1, #self.custom_cards)
			local draw_card = self.custom_cards[which]
			table.remove(self.custom_cards, which)
			table.insert(self.active_cards, draw_card)
			Emit("draw", self.id, draw_card.hash)
		else
			break
		end
	end
end

function Player:elapse_buffs()
	for i, buff in ipairs(self.buffs) do
		local alive = buff:elapse(self, i)
		if not alive then
			table.remove(self.buffs, i)
		end
	end
end

function Player:draw_untapped(acting_player)
	self:draw(self.untapped_count)
	self.untapped_count = 0
	if acting_player ~= self.id then
		self.untapped_count = self.untapped_count + 1
	end
end

return Player

end)



---------------------------------------


__DISTILLER:define("tabletop", function(require)

require "class"
local Player = require "player"

-- 游戏桌面
local Tabletop = class()

function Tabletop:ctor(role_1, role_2)
	assert(_winner, "global var _winner is NIL")
	assert(_user1_nfts, "global var _user1_nfts is NIL")
	assert(_user2_nfts, "global var _user2_nfts is NIL")
	self.round = 1
	self.players = {
		[1] = Player.new(role_1, _user1_nfts, PlayerId.One, self),
		[2] = Player.new(role_2, _user2_nfts, PlayerId.Two, self)
	}
	self.acting_player = FirstPlayer
	for _, player in ipairs(self.players) do
		player:draw_untapped(self.acting_player)
	end
	Emit("new_round", self.acting_player, self.round, 0)
end

function Tabletop:spell_card(which)
	local player = self.players[self.acting_player]
	if which == nil or which == 0 then
		player:spell_master()
	else
		player:spell(which)
	end
	if self:check_winner() then
		Emit("game_over", _winner)
	end
end

function Tabletop:draw_card(count)
	local player = self.players[self.acting_player]
	player:draw(count)
end

function Tabletop:switch_round()
	self.round = self.round + 1
	for _, player in ipairs(self.players) do
		player:elapse_buffs()
	end
	if self:check_winner() then
		Emit("game_over", _winner)
	else
		local last_player = self.acting_player
		self.acting_player = self.acting_player % 2 + 1
		for _, player in ipairs(self.players) do
			player:draw_untapped(self.acting_player)
		end
		Emit("new_round", self.acting_player, self.round, last_player)
	end
end

function Tabletop:check_winner()
	for i, player in ipairs(self.players) do
		if player.hp <= 0 then
			_winner = i % 2 + 1
			return true
		end
	end
	return false
end

function Tabletop:other_player()
	local other_id = self.acting_player % 2 + 1
	return assert(self.players[other_id], "invalid player")
end

return Tabletop

end)



---------------------------------------


__DISTILLER:define("boost.lua_distilled", function(require)

Tabletop = require "tabletop"

PlayerId = {
	One = 1,
	Two = 2
}

Role = {
	Chosen = 1,
	Cultist = 2,
	Ironclad = 3,
	Silent = 4 
}

Cfg = {
	MAX_HP = 30,
	MAX_ENERGY = 10,
}

FirstPlayer = 0

function Init()
	FirstPlayer = math.random(PlayerId.One, PlayerId.Two)
	-- FirstPlayer = PlayerId.Two
	Emit("init", FirstPlayer, Cfg.MAX_HP)
end

function Emit(...)
	local event = table.pack(...)
	local output = "["
	for i, v in ipairs(event) do
		if i == 1 then
			output = output .. v
		else
			output = output .. ", " .. v
		end
	end
	print(output .. "]")
	__events__ = __events__ or {}
	table.insert(__events__, event)
end

end)



---------------------------------------


__DISTILLER:exec("boost.lua_distilled")